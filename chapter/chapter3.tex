\chapter{Redis $\to$ Remote Dictionary Server}

\emph{Redis}, acronimo di \emph{Remote Dictionary Server}, é un archivio dati veloce, open source, in memoria e di tipo chiave-valore(\textbf{dbms NoSQL}).
Si basa su una struttura a dizionario: ogni valore immagazzinato é abbinato ad una chiave univoca che ne permette il recupero.
É stato sviluppato nel linguaggio di programmazione C, e funziona principalmente con sistemi unix based, non esiste un supporto ufficiale
per Windows.
Redis si basa su un modello client-server, infatti i programmi esterni dialogano con il server Redis utilizzando un socket TCP e un protocollo specifico
di tipo request-response.
Il client invia una richiesta al server attendendo la risposta sul socket ed il server elabora il comando e
invia la risposta al client.
Inoltre, é possibile interagire con il server anche da linea di comando con un programma chiamato \texttt{redis-cli}, grazie ad esso viene
semplificato notevolmente il lavoro di hacking con il sistema.\\

\includegraphics[width=1\textwidth]{img/redisClientServer}

\section{Caratteristiche}
\subsection{Strutture Dati}
Una caratteristica di Redis é mettere a disposizione una grande varietá di tipi di dati associabili alle chiavi, infatti il valore archiviato
in corrispondenza di una certa chiave puó essere molto differente da un tipo semplice come la stringa ed il valore stesso puó addirittura
rappresentare una struttura dati. Inoltre vi é una grandissima possibilitá di manipolazione grazie all'elevato numero di funzioni presenti.\\
I principali tipi di dato disponibili sono:
\begin{itemize}
    \item \textbf{Stringhe}: é il tipo piú semplice, vengono memorizzate sequenze di byte, inclusi testo, oggetti serializzati e array binari;
    sono spesso usati per la memorizzazione nella cache;
    \item \textbf{Liste}:rappresentano un elenco di stringhe indicizzate in base all'ordine di inserimento nella struttura. Possono essere
    modificate con inserimenti in testa o in coda. Vi é la possibilitá di trattare una lista come una coda (First In First Out) tramite il comando di inserimento
    \texttt{LPUSH} e il comando di prelievo \texttt{RPOP} oppure puó essere trattata come una pila (First In Last Out) tramite i rispettivi comandi 
    \texttt{LPUSH} e \texttt{LPOP};
    \item \textbf{Set}: é una raccolta non ordinata di stringhe univoche(sono chiamate \emph{membri} del set); quindi vi é la possiblitá
    di utilizzare questa struttura dati per tenere traccia degli elementi univoci, rappresentare relazioni o eseguire operazioni di insiemi
    comuni come intersezioni, unioni e differenze;
    \item \textbf{Hash}: sono oggetti strutturati come raccolte di coppie campo(chiave)-valore. Possono essere utilizzati per rappresentare oggetti
    di base e per memorizzare raggruppamenti di contatori;
    \item \textbf{SortedSet}: sono una versione modificata dei Set. Sono anch'essi insiemi di stringhe che non ammettono duplicati ma, in piú,
    includono un valore detto \texttt{score} associato ad ogni elemento, in base al quale é possibile ordinare in senso ascendento o discendente i valori
    dell'insieme.
\end{itemize}
    Ovviamente associati a queste strutture dati vi sono molti comandi specifici per ognuna, analizzare tutti i comandi non ha molto senso, quindi
    ogni volta che verranno incontrati dei comandi particolari verranno illustrati in quel momento.


\subsection{\emph{proprietá ACID}}
%FIXME: questa introduzione
Nelle basi di dati relazionali ogni transazione gode delle proprietá ACID. in questa sezione l'obiettivo é mettere in evidenza
quali proprietá vengono verificate da questo dbms, se c'é la possibilitá di abilitare/disabilitare certe proprieta e cosí via.

Innanzitutto, bisogna vedere in che modo sono gestite le transazioni in Redis:\\
i comandi utilizzati per le transazioni sono quattro:
\begin{itemize}
    \item \texttt{MULTI}: contrassegna l'inizio di un blocco di transazione, i comandi successivi verranno accodati per l'esecuzione
    \item \texttt{EXEC}: esegue tutti i comandi precedentemente accodati in una transazione e ripristina lo stato di connessione normale;
    \item \texttt{DISCARD}: svuota tutti i comandi precedentemente accodati in una transazione e ripristina lo stato di connessione normale;
    \item \texttt{WATCH}: contrassegna le chiavi fornite con un certo valore per eseguire un controllo condizionale al momento dell'esecuzione
    di una transazione (serve per la gestione di lock, ovvero controllo della concorrenza)
\end{itemize}

Quindi una transazione viene eseguita in questo modo:
\begin{enumerate}
    \item inviamo il comando \texttt{MULTI}. Redis risponde \texttt{OK};
    \item digitiamo i comandi che devono far parte della transazione. Redis risponde \texttt{QUEUED}, ovvero il comando non viene eseguito
    istantaneamente ma viene messo in coda;
    \item conclusione della transazione: si puó scegliere se eseguire tutti i comandi con \texttt{EXEC} oppure annullare la transazione
    con \texttt{DISCARD}.
\end{enumerate}

Di seguito riporto un esempio utilizzando \texttt{redis-cli} con la struttura dati lista, quindi i comandi per gestire le liste in questo esempio
sono 2: \texttt{LPUSH} comando per inserire un singolo elemento nella lista e \texttt{LRANGE} comando per ottenere tutti i valori presenti nella lista

\includegraphics[width=0.7\textwidth]{img/transazioneRedis}\\
Si puó notare come l'inserimento di tutti i valori nella lista avvenga dopo il comando \texttt{EXEC}.\\

Quindi, passando all'illustrazione delle proprietá ACID:
\begin{itemize}
    \item \textbf{Atomicitá}: Redis puó avere due livelli di atomicitá:
      \begin{itemize}
          \item singola operazione: ovvero ogni singola richiesta da parte del client viene eseguita in maniera atomica dal server;
          \item transazione con operazioni multiple: come illustrato sopra con i vari comandi \texttt{MULTI}, \texttt{EXEC} ...;
      \end{itemize}

    \item \textbf{Isolamento}:
    Tutti i comandi in una transazione vengono serializzati ed eseguiti in sequenza. Una richiesta inviata da un altro client
    non sará mai soddisfatta nel bel mezzo dell'esecuzione di una transazione. Ció garantisce che i comandi vengano eseguiti
    come un'unica operazione isolata.\\
    Inoltre, vi é un meccanismo che riesce a fornire delle garanzie aggiuntive, in cui viene fatta una sorta di operazione
    di check-and-set.
    Questo meccanisco utilizza il comando \texttt{WATCH} definito precedentemente.
    Le chiavi, su cui viene definito watch, vengono continuamente monitorate per eventuali modifiche; se anche una sola chiave monitorata
    da \texttt{WATCH }viene modificata prima della \texttt{EXEC}, l'intera transazione verrá abortita.\\

    Consideriamo un esempio in pseudo-codice in cui si deve aumentare il valore di una chiave di 1.

    \begin{lstlisting}[autogobble]
       num = GET sampleKey
       num = num + 1
       SET sampleKey num\end{lstlisting}

    i comandi mostrati sopra funzioneranno senza problemi purché sia presente un solo utente che esegue l'operazione in un determinato momento.\\
    Il problema si verifica nel caso in cui ci siano piú utenti che tentano di aumentare il valore della chiave contemporaneamente.
    Possiamo eliminare questo potenziale problema di race condition utilizzando il comando \texttt{WATCH} nel modo seguente:

    \begin{lstlisting}[autogobble]
       WATCH sampleKey
       num = GET sampleKey
       num = num + 1
       MULTI
       SET sampleKey num
       EXEC\end{lstlisting}

    Con questa implementazione, se si dovesse verificare una race condition ed un client modifica il valore di \texttt{sampleKey} tra il nostro
    \texttt{WATCH} e \texttt{EXEC}, la transazione verrá interrotta. Avremo bisogno di ripetere la transazione quando la race condition non sará
    piú presente.\\
    Quindi questo é un modo efficace per ottenere un buon livello di isolamento a livello di transazioni.

    \item \textbf{consistenza}: I vincoli di integritá sono dei concetti relazionali, quindi é difficile fare un collegamento con un database di questo tipo.
    L'unica chiave che esiste é quella primaria e deve essere univoca;
    l'integrita referenziale non é mantenuta da Redis stesso e deve essere gestita dalle applicazioni client.

    \item \textbf{persistenza(durability)}:
    l'efficienza di Redis é dovuta in buona parte al suo modo di gestire questa proprietá.
    É un database in memoria ma con possibilitá di essere persistente su disco, quindi rappresenta un compromesso in cui si ottengono
    velocitá di scrittura e lettura molto elevate con la limitazione di avere un set di dati non piú grande della memoria.
    Questo database mette a disposizione la possibilitá di scegliere tra diversi meccanismi
    offrendo l'opportunitá di salvare database
    totalmente su disco oppure no.\\
    I meccanismi, che verranno illustrati di seguito, sono:
      \begin{itemize}
          \item \textbf{RDB}
          \item \textbf{AOF}
          \item \textbf{Database in Memory}
      \end{itemize}%parlate anche dei dati salvati in cache, vantaggi/svantaggi che ne derivano
        
       \paragraph{RDB $\to$ Redis Database File}
         Questo tipo di persistenza esegue snapshot del set di dati a intervalli specificati. Viene prodotto come risultato un file
         compatto, pertanto agevole da salvare su qualsiasi tipo di supporto. Inoltre, il recupero dei dati all'avvio del server Redis
         é molto efficiente.
         Il salvataggio dei dati viene eseguito su file ad intervalli di tempo e non con continuitá, quindi questo potrebbe essere un punto a sfavore
         nel caso di crash del sistema tra uno snapshot ed un altro con conseguente perdita dei dati.
         Conviene utilizzare questo tipo di persistenza quando si richiede un salvataggio meno oneroso per il server e si ha particolare interesse
         ad avere un backup piú comodo.

    \paragraph{AOF $\to$ Append Only File}
    é un meccanismo di persistenza che consente al server Redis di tenere traccia e registrare ogni comando eseguito dal server.
    Quindi vi é un file di log dove vengono aggiunti i comandi ogni volta che vengono eseguiti.
    Questo registro di comandi puó essere riprodotto all'avvio del server, ricreando il database al suo stato originale.
    Il vantaggio é che basandosi su un log scritto continuamente, non vi é il rischio di incorrere in perdite in caso di crash. Inoltre,
    il formato dei file che vengono prodotti da questa modalitá permette un recupero piú semplice in caso di corruzione.
    Peró, i file AOF risultano meno compatti e piú voluminosi rispetto a quelli in formato RDB e da ció consegue un ripristino del database
    meno rapido all'avvio. Questo meccanismo viene utilizzato quando la principale preoccupazione é la perdita di dati.\\

    É possibile utilizzare contemporaneamente AOF e RDB, e durante il ripristino del database verrá preferito l'utilizzo di file AOF per la loro
    maggiore completezza.


    \paragraph{Database In Memory}
    é possibile rinunciare ad entrambi i meccanismi definiti precedentemente per dare vita ad un database in memory, risultando molto piú
    efficiente, poiché non deve piú occuparsi dei salvataggi su disco, e puó essere utilizzato per immagazzinare dati ad uso temporaneo la cui
    perdita non risulterebbe irreparabile per il sistema.\\
    Redis puó anche essere utilizzato come memoria cache, in cui viene fissata la quantitá massima di memoria utilizzabile. Quando questa sará
    colma, i dati piú vecchi verranno eliminato con una politica LRU o LFU.
\end{itemize}

\paragraph{Come configurare i diversi livelli di persistenza?\\}
Per fare ció bisogna accedere al file di configurazione del server Redis andando a modificare/cancellare dei parametri.



%configurazione della persistenza, fare vedere come configurare il file di configurazione per le varie persistenze


\subsection{Ambiti di utilizzo}

\subsection{sistema distribuito (cenni)}
%teorema cap, proprietá base





%Le principali caratteristiche sono la velocitá e la struttura semplice dei database. Infatti, i dati vengono scritti direttamente sulla
%memoria RAM del server e possono essere richiamati molto piú velocemente rispetto ad altri database.
